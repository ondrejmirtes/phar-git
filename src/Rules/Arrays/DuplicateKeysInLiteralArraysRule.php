<?php

declare (strict_types=1);
namespace PHPStan\Rules\Arrays;

use PhpParser\Node;
use PHPStan\Analyser\Scope;
use PHPStan\Node\LiteralArrayNode;
use PHPStan\Node\Printer\ExprPrinter;
use PHPStan\Rules\Rule;
use PHPStan\Rules\RuleErrorBuilder;
use PHPStan\Type\Constant\ConstantIntegerType;
use function array_key_first;
use function array_keys;
use function array_search;
use function count;
use function implode;
use function is_int;
use function max;
use function sprintf;
use function var_export;
/**
 * @implements Rule<LiteralArrayNode>
 */
final class DuplicateKeysInLiteralArraysRule implements Rule
{
    private ExprPrinter $exprPrinter;
    public function __construct(ExprPrinter $exprPrinter)
    {
        $this->exprPrinter = $exprPrinter;
    }
    public function getNodeType(): string
    {
        return LiteralArrayNode::class;
    }
    public function processNode(Node $node, Scope $scope): array
    {
        $duplicateKeys = [];
        $printedValues = [];
        $valueLines = [];
        /**
         * @var int|false|null $autoGeneratedIndex
         * - An int value represent the biggest integer used as array key.
         *   When no key is provided this value + 1 will be used.
         * - Null is used as initializer instead of 0 to avoid issue with negative keys.
         * - False means a non-scalar value was encountered and we cannot be sure of the next keys.
         */
        $autoGeneratedIndex = null;
        $seenKeys = [];
        $seenUnions = [];
        foreach ($node->getItemNodes() as $itemNode) {
            $item = $itemNode->getArrayItem();
            if ($item === null) {
                $autoGeneratedIndex = \false;
                continue;
            }
            $key = $item->key;
            if ($key === null) {
                if ($autoGeneratedIndex === \false) {
                    continue;
                }
                if ($autoGeneratedIndex === null) {
                    $autoGeneratedIndex = 0;
                    $keyType = new ConstantIntegerType(0);
                } else {
                    $keyType = new ConstantIntegerType(++$autoGeneratedIndex);
                }
            } else {
                $keyType = $itemNode->getScope()->getType($key);
                $arrayKeyValues = $keyType->toArrayKey()->getConstantScalarValues();
                if (count($arrayKeyValues) === 1 && is_int($arrayKeyValues[0])) {
                    $autoGeneratedIndex = $autoGeneratedIndex === null ? $arrayKeyValues[0] : max($autoGeneratedIndex, $arrayKeyValues[0]);
                }
            }
            $keyValues = $keyType->getConstantScalarValues();
            if (count($keyValues) === 0) {
                $autoGeneratedIndex = \false;
                continue;
            }
            $duplicate = \false;
            $newValues = $keyValues;
            foreach ($newValues as $k => $newValue) {
                if (array_search($newValue, $seenKeys, \true) !== \false) {
                    unset($newValues[$k]);
                }
                if ($newValues === []) {
                    $duplicate = \true;
                    break;
                }
            }
            if ($newValues !== []) {
                if (count($newValues) === 1) {
                    $newValue = $newValues[array_key_first($newValues)];
                    foreach ($seenUnions as $k => $union) {
                        $offset = array_search($newValue, $union, \true);
                        if ($offset === \false) {
                            continue;
                        }
                        unset($seenUnions[$k][$offset]);
                        // turn a union into a seen key, when all its elements have been seen
                        if (count($seenUnions[$k]) !== 1) {
                            continue;
                        }
                        $seenKeys[] = $seenUnions[$k][array_key_first($seenUnions[$k])];
                        unset($seenUnions[$k]);
                    }
                    $seenKeys[] = $newValue;
                } else {
                    $seenUnions[] = $newValues;
                }
            }
            foreach ($keyValues as $value) {
                $printedValue = $key !== null ? $this->exprPrinter->printExpr($key) : $value;
                $printedValues[$value][] = $printedValue;
                if (!isset($valueLines[$value])) {
                    $valueLines[$value] = $item->getStartLine();
                }
                if (!$duplicate) {
                    continue;
                }
                $duplicateKeys[$value] = \true;
            }
        }
        $messages = [];
        foreach (array_keys($duplicateKeys) as $value) {
            $messages[] = RuleErrorBuilder::message(sprintf('Array has %d %s with value %s (%s).', count($printedValues[$value]), count($printedValues[$value]) === 1 ? 'duplicate key' : 'duplicate keys', var_export($value, \true), implode(', ', $printedValues[$value])))->identifier('array.duplicateKey')->line($valueLines[$value])->build();
        }
        return $messages;
    }
}
