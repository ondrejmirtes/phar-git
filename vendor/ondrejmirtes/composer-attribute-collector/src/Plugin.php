<?php

namespace _PHPStan_checksum\olvlvl\ComposerAttributeCollector;

use _PHPStan_checksum\Composer\Composer;
use _PHPStan_checksum\Composer\EventDispatcher\EventSubscriberInterface;
use _PHPStan_checksum\Composer\IO\IOInterface;
use _PHPStan_checksum\Composer\Plugin\PluginInterface;
use _PHPStan_checksum\Composer\Script\Event;
use _PHPStan_checksum\Composer\Util\Platform;
use _PHPStan_checksum\olvlvl\ComposerAttributeCollector\Datastore\FileDatastore;
use _PHPStan_checksum\olvlvl\ComposerAttributeCollector\Datastore\RuntimeDatastore;
use _PHPStan_checksum\olvlvl\ComposerAttributeCollector\Filter\ContentFilter;
use PhpParser\ParserFactory;
use function file_exists;
use function file_put_contents;
use function microtime;
use function sprintf;
use const DIRECTORY_SEPARATOR;
/**
 * @internal
 */
final class Plugin implements PluginInterface, EventSubscriberInterface
{
    public const CACHE_DIR = '.composer-attribute-collector';
    public const VERSION_MAJOR = 2;
    public const VERSION_MINOR = 0;
    /**
     * @uses onPostAutoloadDump
     *
     * @codeCoverageIgnore
     */
    public static function getSubscribedEvents(): array
    {
        return ['post-autoload-dump' => 'onPostAutoloadDump'];
    }
    /**
     * @codeCoverageIgnore
     */
    public function activate(Composer $composer, IOInterface $io): void
    {
        $vendorDir = Config::resolveVendorDir($composer);
        $filename = $vendorDir . DIRECTORY_SEPARATOR . "attributes.php";
        if (file_exists($filename)) {
            return;
        }
        $stub = <<<PHP
        <?php
        
        // attributes.php @generated by https://github.com/olvlvl/composer-attribute-collector
        // This is a placeholder to enable the rendering of the autoloader.
        
        PHP;
        file_put_contents($filename, $stub);
    }
    /**
     * @codeCoverageIgnore
     */
    public function deactivate(Composer $composer, IOInterface $io): void
    {
    }
    /**
     * @codeCoverageIgnore
     */
    public function uninstall(Composer $composer, IOInterface $io): void
    {
    }
    public static function onPostAutoloadDump(Event $event): void
    {
        $composer = $event->getComposer();
        $config = Config::from($composer);
        $io = $event->getIO();
        require_once $config->vendorDir . "/autoload.php";
        $start = microtime(\true);
        $io->write('<info>Generating attributes file</info>');
        self::dump($config, $io);
        $elapsed = self::renderElapsedTime($start);
        $io->write("<info>Generated attributes file in {$elapsed}</info>");
    }
    public static function dump(Config $config, IOInterface $io): void
    {
        //
        // Scan the included paths
        //
        $start = microtime(\true);
        $datastore = self::buildDefaultDatastore($config, $io);
        $classMapGenerator = new MemoizeClassMapGenerator($datastore, $io);
        foreach ($config->include as $include) {
            $classMapGenerator->scanPaths($include, $config->excludeRegExp);
        }
        $classMap = $classMapGenerator->getMap();
        $elapsed = self::renderElapsedTime($start);
        $io->debug("Generating attributes file: scanned paths in {$elapsed}");
        //
        // Filter the class map
        //
        $start = microtime(\true);
        $classMapFilter = new MemoizeClassMapFilter($datastore, $io);
        $filter = self::buildFileFilter();
        $classMap = $classMapFilter->filter($classMap, fn(string $class, string $filepath): bool => $filter->filter($filepath, $class, $io));
        $elapsed = self::renderElapsedTime($start);
        $io->debug("Generating attributes file: filtered class map in {$elapsed}");
        //
        // Collect attributes
        //
        $start = microtime(\true);
        $parserFactory = new ParserFactory();
        $parser = $parserFactory->createForNewestSupportedVersion();
        $attributeCollector = new MemoizeAttributeCollector(new ClassAttributeCollector($io, $parser), $datastore, $io);
        $collection = $attributeCollector->collectAttributes($classMap);
        $elapsed = self::renderElapsedTime($start);
        $io->debug("Generating attributes file: collected attributes in {$elapsed}");
        //
        // Render attributes
        //
        $start = microtime(\true);
        $code = self::render($collection);
        file_put_contents($config->attributesFile, $code);
        $elapsed = self::renderElapsedTime($start);
        $io->debug("Generating attributes file: rendered code in {$elapsed}");
    }
    private static function buildDefaultDatastore(Config $config, IOInterface $io): Datastore
    {
        if (!$config->useCache) {
            return new RuntimeDatastore();
        }
        $basePath = Platform::getCwd();
        \assert($basePath !== '');
        return new FileDatastore($basePath . DIRECTORY_SEPARATOR . self::CACHE_DIR, $io);
    }
    private static function renderElapsedTime(float $start): string
    {
        return sprintf("%.03f ms", (microtime(\true) - $start) * 1000);
    }
    private static function buildFileFilter(): Filter
    {
        return new Filter\Chain([new ContentFilter()]);
    }
    private static function render(TransientCollection $collector): string
    {
        return TransientCollectionRenderer::render($collector);
    }
}
